                    +--------------------------+
                    |          CS 140          |
                    | PROJECT 2: USER PROGRAMS |
                    |     DESIGN DOCUMENT      |
                    +--------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Alexandra Klimenko <klimenko@usc.edu>
Rohan Sharma <sharmaro@usc.edu>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

			   ARGUMENT PASSING
			   ================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

Thread has new members which allow blocking of parent or child threads, 
respectively, namely we list them (and initialize them init_thread) below as:
bool has_exited (set in proc_exit)
bool has_waited (used in proc_wait to designate that proc started to wait)
bool has_loaded (used in proc_exec to determine whether to return an error based
 on whether child loaded file and setup_stack successfully) 
struct list children (and associated childelem)
sema_exec, sema_wait, sema_exit -> semaphores used for context switching in 
eponymous functions (also start_process where it relates to proc_exec)
tid_t parent_id
int exit_status 

---- ALGORITHMS ----

>> A2: Briefly describe how you implemented argument parsing.  How do
>> you arrange for the elements of argv[] to be in the right order?
>> How do you avoid overflowing the stack page?

We modified “setup_stack” that is called in load, after the point at 
which load could fail (therefore if load fails there is no attempt to write to the stack). 

In order to set up the stack we create a copy of the filename with the passed in parameters,
 wrote their values (split by spaces using strtok_r) to the stack in reverse order by calling
 helper functions. We then have helper functions called reverseFileName() and reverseHelper() 
that help reverse the arguments in the string. 

Keeping track of the eventual addresses of the arguments on the stack is done as follows: 
decrement *esp by argument length plus one; push argument onto stack, store address and number of 
parameters, continue. Attempting to push too many arguments to the stack results in exiting with the error status code (-1).

---- RATIONALE ----

>> A3: Why does Pintos implement strtok_r() but not strtok()?

strtok() operates on just one buffer which is static; multiple threads accessing this buffer 
at the same time would be a bad scenario.

>> A4: In Pintos, the kernel separates commands into a executable name
>> and arguments.  In Unix-like systems, the shell does this
>> separation.  Identify at least two advantages of the Unix approach.

1) By separating the commands, Unix can then perform useful pre-processing. 
It can allow multiple commands on the command line at once.
2) This allows less time spent in the kernel, meaning faster operations.

			     SYSTEM CALLS
			     ============

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

struct list files_opened: Keeps track of all the files that were opened 
by a thread so we could see if the same file was being opened multiple times.
struct list files_closed: Keeps track of all the files that were closed 
by a thread so we could determine the close-twice test.
struct FDToFile: This struct was used to hold information about a file given its fd. 
It was useful in comparing two different files that were either opened or closed.

>> B2: Describe how file descriptors are associated with open files.
>> Are file descriptors unique within the entire OS or just within a
>> single process?

We created a wrapper class for the pointer returned by filesys_open and 
its relevant file descriptor. A file descriptor is generated by looking at the 
last element in the list of open files and then adding one to the last 
file's descriptor, ensuring its uniqueness across the OS.

---- ALGORITHMS ----

>> B3: Describe your code for reading and writing user data from the
>> kernel.

In order to read and write user data, firstly, we validate that the data 
is accessed by the user for the correct address by using a helper function 
is_bad_ptr to make sure it isn’t trying to access what it is not allowed or/and is not valid. 

>> B4: Suppose a system call causes a full page (4,096 bytes) of data
>> to be copied from user space into the kernel.  What is the least
>> and the greatest possible number of inspections of the page table
>> (e.g. calls to pagedir_get_page()) that might result?  What about
>> for a system call that only copies 2 bytes of data?  Is there room
>> for improvement in these numbers, and how much?

For a full page of data the least number of inspections is 1 and the 
greatest is 4096. It can be 1 if the first inspection is the page head, 
so there does not need to be any more inspections. It can be 4096 if if 
each byte needs to be inspected. If 2 bytes, the minimum would still be 
one and the max would be two because it is the number of bytes given.

>> B5: Briefly describe your implementation of the "wait" system call
>> and how it interacts with process termination.

If the child process has_exited, the child's exit_status is returned; 
otherwise decrement child’s sema_wait to keep the parent from having 
an exit_status until the child’s sema_wait is incremented (and sema_exit 
decremented) indicating that the child has been assigned an exit_status 
to be inherited by the parent.  Finally, the parent may increment the 
child’s sema_exit, allowing the child to successfully exit.


>> B6: Any access to user program memory at a user-specified address
>> can fail due to a bad pointer value.  Such accesses must cause the
>> process to be terminated.  System calls are fraught with such
>> accesses, e.g. a "write" system call requires reading the system
>> call number from the user stack, then each of the call's three
>> arguments, then an arbitrary amount of user memory, and any of
>> these can fail at any point.  This poses a design and
>> error-handling problem: how do you best avoid obscuring the primary
>> function of code in a morass of error-handling?  Furthermore, when
>> an error is detected, how do you ensure that all temporarily
>> allocated resources (locks, buffers, etc.) are freed?  In a few
>> paragraphs, describe the strategy or strategies you adopted for
>> managing these issues.  Give an example.

Before allocating any resources, we checked to see if any user memory 
that needed access failed or not, then, if everything was working correctly, 
we allocate our resources and performed our operations. For many functions in process.c, 
several checks ensure that tasks are completed as intended, otherwise free up allocated resources.

---- SYNCHRONIZATION ----

>> B7: The "exec" system call returns -1 if loading the new executable
>> fails, so it cannot return before the new executable has completed
>> loading.  How does your code ensure this?  How is the load
>> success/failure status passed back to the thread that calls "exec"?

If load was successful (determined in start_process where our has_loaded 
boolean inside the thread struct is set according to the return value of calling load, 
in addition to the sema_exec being incremented), inside proc_exec the tid which was 
allocated in thread_create is returned (otherwise -1 is returned). To ensure proper synchronization, 
there is a sema_exec inside the child thread (which we fetch inside proc_exec 
using a helper method inside thread.c with the tid returned by thread_create).

>> B8: Consider parent process P with child process C.  How do you
>> ensure proper synchronization and avoid race conditions when P
>> calls wait(C) before C exits?  After C exits?  How do you ensure
>> that all resources are freed in each case?  How about when P
>> terminates without waiting, before C exits?  After C exits?  Are
>> there any special cases?

After validating the child in proc_wait, namely that it exists in the first place 
and this is the first time it is being asked to wait by its own parent, 
the child’s sema_wait is incremented if the child has exited and the return 
status is returned after sema_exit is incremented  (otherwise sema_wait is 
decremented while sema_exit is incremented). If the parent is terminated before the child, 
the parent must do the additional step of clearing the child’s parent_id struct field. 

---- RATIONALE ----

>> B9: Why did you choose to implement access to user memory from the
>> kernel in the way that you did?

is_user_vaddr is called to confirm the pointer’s virtual address being 
below PHYS_BASE, and pagedir_get_page confirms its belonging to the map 
of the current thread’s page directory. This is a very handy helper 
method that may be used broadly without “reinventing the wheel”.

>> B10: What advantages or disadvantages can you see to your design
>> for file descriptors?

We didn’t provide a complete implementation where the “owner” of the 
file is kept track of inside the thread which opened the file. 
Closing a file involves running through the entire list of opened files. 


>> B11: The default tid_t to pid_t mapping is the identity mapping.
>> If you changed it, what advantages are there to your approach?

No change, in fact we never used pid_t only tid_t.



                          SURVEY QUESTIONS
                          ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

 
>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?
 Too long

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?
setup stack..wish we did it before midterm(would have not lost 3 points)

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

 
>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?
 
>> Any other comments?
As the deadline approaches, would be nice if CPs had more OH.

